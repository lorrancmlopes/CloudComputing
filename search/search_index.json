{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Roteiro: configura\u00e7\u00e3o de uma fun\u00e7\u00e3o do Lambda para acessar o Amazon RDS em uma Amazon VPC","text":"<ul> <li>Aluno: Lorran Caetano Machado Lopes</li> <li>Curso: Engenharia da Computa\u00e7\u00e3o</li> <li>Semestre: 6</li> <li>Contato: lorrancml@al.insper.edu.br</li> <li>Ano: 2023</li> </ul>"},{"location":"#pre-requisitos","title":"Pr\u00e9-requisitos","text":"<p>Para seguir esse tutorial \u00e9 necess\u00e1rio:</p> <ul> <li>Ubuntu &gt; 20.0 ou WSL2</li> <li>Conta da AWS:  uma conta com permiss\u00f5es de administrador.</li> <li>Terraform </li> </ul> <p>Info</p> <p>Voc\u00ea pode se cadastrar em uma conta da AWS aqui:</p> <ul> <li>http://portal.aws.amazon.com/billing/signup</li> </ul> <p>Caso n\u00e3o tenha o Terraform instalado em sua m\u00e1quina, voc\u00ea pode obt\u00ea-lo aqui:</p> <ul> <li>https://developer.hashicorp.com/terraform/downloads</li> </ul>"},{"location":"#motivacao","title":"Motiva\u00e7\u00e3o","text":"<p>Ao concluir esse roteiro, teremos provisionado uma arquitetura que contem uma fun\u00e7\u00e3o Lambda que grava dados em um dos dois banco de dados do Amazon RDS (clientes ou produtos), por meio da leitura de dados de uma fila do Amazon SQS sempre que uma mensagem \u00e9 adicionada.  Ao usar o Lambda para acessar seu banco de dados, voc\u00ea pode ler e gravar dados em resposta a eventos. Sua fun\u00e7\u00e3o e inst\u00e2ncia de banco de dados tamb\u00e9m se escalam automaticamente para atender a per\u00edodos de alta demanda. Al\u00e9m disso, ser\u00e1 enviado um e-mail para um endere\u00e7o definido a fim de ser notificado quando o banco de dados for alterado.</p>"},{"location":"#atualizar","title":"Atualizar!!!!!!!!!!!!!!!","text":""},{"location":"#_1","title":"Home","text":""},{"location":"#aws","title":"AWS","text":"<p>A Amazon Web Services (AWS) \u00e9 a plataforma de nuvem mais adotada e mais abrangente do mundo, oferecendo mais de 200 servi\u00e7os completos de datacenters em todo o mundo. Milh\u00f5es de clientes, incluindo as startups que crescem mais r\u00e1pido, as maiores empresas e os maiores \u00f3rg\u00e3os governamentais, est\u00e3o usando a AWS para reduzir custos, ganhar agilidade e inovar mais rapidamente.</p> <p>Para conseguir interagir com os servi\u00e7os e fun\u00e7\u00f5es que a AWS prov\u00e9m, por meio de IaC (Infrastructure as Code), \u00e9 necess\u00e1rio obter chaves de acesso, que permitam o gerenciamento e provisionamento dos recursos que desejamos alocar na nuvem.</p> <p>Guarde a chave de acesso para criar vari\u00e1veis de ambiente antes de iniciar o Terraform, na fase final do roteiro.</p>"},{"location":"#rds","title":"RDS","text":"<p>O Amazon RDS (Relational Database Service) \u00e9 um servi\u00e7o de banco de dados gerenciado da AWS que permite criar e gerenciar bancos de dados relacionais, como MySQL, PostgreSQL, Oracle, SQL Server, entre outros. O RDS gerencia tarefas como provisionamento de hardware, instala\u00e7\u00e3o de software, backup e recupera\u00e7\u00e3o, bem como monitoramento e dimensionamento autom\u00e1tico.</p>"},{"location":"#funcoes-aws-lambda","title":"Fun\u00e7\u00f5es AWS Lambda","text":"<p>O AWS Lambda \u00e9 um servi\u00e7o de computa\u00e7\u00e3o sem servidor e orientado a eventos que permite executar c\u00f3digo para praticamente qualquer tipo de aplica\u00e7\u00e3o ou servi\u00e7o de backend sem provisionar ou gerenciar servidores. \u00c9 poss\u00edvel acionar o Lambda a partir de mais de 200 servi\u00e7os da AWS e aplica\u00e7\u00f5es de software como servi\u00e7o (SaaS). Nesse roteiro, voc\u00ea ir\u00e1 usar o Lambda para abrir uma conex\u00e3o com uma inst\u00e2ncia de banco de dados do Amazon RDS e para realizar opera\u00e7\u00f5es de cria\u00e7\u00e3o e leitura em um banco de dados do Amazon RDS.</p>"},{"location":"#aws-sqs","title":"AWS SQS","text":"<p>O Amazon Simple Queue Service (AWS SQS) \u00e9 um servi\u00e7o de mensagens gerenciadas pela Amazon Web Services (AWS) que permite que diferentes componentes de um sistema se comuniquem entre si de forma ass\u00edncrona. Ele funciona como uma fila virtual, onde as mensagens s\u00e3o armazenadas at\u00e9 que sejam processadas pelos consumidores. O SQS garante a entrega das mensagens, mesmo em situa\u00e7\u00f5es de alta demanda ou falhas tempor\u00e1rias, tornando-o uma solu\u00e7\u00e3o escal\u00e1vel e confi\u00e1vel para sistemas distribu\u00eddos.</p>"},{"location":"#amazon-simple-notification-service-sns","title":"Amazon Simple Notification Service (SNS)","text":"<p>O SNS \u00e9 um servi\u00e7o de mensagens e notifica\u00e7\u00e3o da AWS que permite enviar mensagens para diferentes tipos de endpoints como emails, mensagens de texto(SMS), URLs entre outros. Al\u00e9m disso, voc\u00ea pode configurar o acesso para quem pode publicar e para quem pode se inscrever no t\u00f3pico.</p>"},{"location":"#amazon-cloudwatch","title":"Amazon CloudWatch","text":"<p>O Amazon CloudWatch \u00e9 um servi\u00e7o de monitoramento e observabilidade oferecido pela Amazon Web Services (AWS). Ele permite que voc\u00ea colete, monitore e analise m\u00e9tricas, logs e eventos gerados pelos recursos e aplicativos em execu\u00e7\u00e3o na AWS. O CloudWatch oferece uma vis\u00e3o abrangente do desempenho e sa\u00fade dos seus sistemas, permitindo que voc\u00ea identifique problemas, tome decis\u00f5es baseadas em dados e tome a\u00e7\u00f5es corretivas.</p>"},{"location":"#iniciando-nossa-infraestrutura","title":"Iniciando nossa infraestrutura","text":"<p>Crie uma pasta para organizar nossos arquivos chamada terraform:</p> <pre><code>mkdir terraform \ncd terraform\n</code></pre> <p>Crie tamb\u00e9m um arquivo main.tf. Nele, criaremos todos os nossos recursos.</p> <pre><code>touch main.tf\n</code></pre> <p>Primeiramente, iremos criar duas inst\u00e2ncias de banco de dados do Amazon RDS, uma para clientes e outra para produtos. Para tanto, podemos inserir o trecho abaxaixo no nosso main.tf:</p> main.tf<pre><code># Cria uma inst\u00e2ncia de banco de dados do Amazon RDS - Clientes(ID, Nome)\nresource \"aws_db_instance\" \"clients\" {\nengine                = \"mysql\"\nidentifier            = \"mysqlforlambdaterraformclients\"\nallocated_storage     = 5\nmax_allocated_storage = 100\ninstance_class        = \"db.t2.micro\"\npublicly_accessible   = false\n\ndb_name             = \"ExampleDB\"\nusername            = \"admin\"\npassword            = \"senhaDoBancoDeDados\"\nskip_final_snapshot = true\n\nvpc_security_group_ids = [aws_default_security_group.default.id]\n}\n\n# Cria uma outra inst\u00e2ncia de banco de dados do Amazon RDS - Produto(ID, Nome, Price)\nresource \"aws_db_instance\" \"products\" {\nengine                = \"mysql\"\nidentifier            = \"mysqlforlambdaterraformproducts\"\nallocated_storage     = 5\nmax_allocated_storage = 100\ninstance_class        = \"db.t2.micro\"\npublicly_accessible   = false\n\ndb_name             = \"ExampleDB\"\nusername            = \"admin\"\npassword            = \"senhaDoBancoDeDados\"\nskip_final_snapshot = true\n\nvpc_security_group_ids = [aws_default_security_group.default.id]\n}\n</code></pre> <p> Voc\u00ea pode alterar o db_name, username e password pelos valores que voc\u00ea deseja para os seus banco de dados. </p> <p>Agora, antes de criar sua fun\u00e7\u00e3o do Lambda, voc\u00ea deve criar um perfil de execu\u00e7\u00e3o para dar \u00e0 sua fun\u00e7\u00e3o as permiss\u00f5es necess\u00e1rias. Para este roteiro, o Lambda precisa de permiss\u00e3o para gerenciar a conex\u00e3o de rede com a Amazon VPC contendo sua inst\u00e2ncia de banco de dados, para pesquisar mensagens de uma fila do Amazon SQS e para criar grupos de logs, fluxos de logs e enviar eventos de logs. </p> <p>Faremos isso pelo IAM. Vamos adicionar a cria\u00e7\u00e3o no main.tf.</p> main.tf<pre><code># C\u00f3digo j\u00e1 existente omitido\n# ...\n\n# Cria um perfil de execu\u00e7\u00e3o de fun\u00e7\u00e3o\nresource \"aws_iam_role\" \"role\" {\nname = \"lambda-vpc-sqs-role-terraform\"\nassume_role_policy = jsonencode({\nVersion = \"2012-10-17\"\nStatement = [{\nAction = \"sts:AssumeRole\"\nEffect = \"Allow\"\nPrincipal = {\nService = \"lambda.amazonaws.com\"\n}\n}]\n})\n}\n\n# Cria uma policy \nresource \"aws_iam_policy\" \"policy\" {\nname = \"necessary-policy\"\npolicy = jsonencode({\n\"Version\" : \"2012-10-17\",\n\"Statement\" : [\n{\n\"Sid\" : \"VisualEditor0\",\n\"Effect\" : \"Allow\",\n\"Action\" : [\n\"ec2:CreateNetworkInterface\",\n\"ec2:DescribeNetworkInterfaces\",\n\"ec2:DeleteNetworkInterface\"\n],\n\"Resource\" : \"*\"\n},\n{\n\"Effect\" : \"Allow\",\n\"Action\" : [\n\"sqs:ReceiveMessage\",\n\"sqs:DeleteMessage\",\n\"sqs:GetQueueAttributes\",\n\"sqs:SendMessage\",\n\"sqs:GetQueueUrl\"\n],\n\"Resource\" : \"*\"\n},\n{\n\"Effect\" : \"Allow\",\n\"Action\" : [\n\"logs:CreateLogGroup\",\n\"logs:CreateLogStream\",\n\"logs:PutLogEvents\"\n],\n\"Resource\" : \"arn:aws:logs:*:*:*\"\n}\n]\n})\n}\n\n\n#associamos a policy \u00e0 fun\u00e7\u00e3o IAM\nresource \"aws_iam_role_policy_attachment\" \"example\" {\npolicy_arn = aws_iam_policy.policy.arn\nrole       = aws_iam_role.role.name\n}\n</code></pre> <p>Vamos agora criar o pacote de implanta\u00e7\u00e3o do Lambda.</p> <p>Primeiramente, vamos criar uma pasta que servir\u00e1 para a instala\u00e7\u00e3o da biblioca que usaremos no c\u00f3digo Python e o arquivo em si, que ser\u00e3o compactados posteriormente.</p> <p>Rode o comando abaixo no terminal para criar a pasta com o nome source_lambda:</p> <p><pre><code>mkdir source_lambda \n</code></pre> Agora, vamos instalar a biblioteca na pasta criada:</p> <pre><code>pip install --target source_lambda pymysql\n</code></pre> <p>Feito isso, vamos criar o nosso c\u00f3digo para a fun\u00e7\u00e3o Lambda.</p> <p>O exemplo de c\u00f3digo Python a seguir usa o pacote PyMySQL para abrir uma conex\u00e3o com seu banco de dados. Na primeira vez que voc\u00ea invoca sua fun\u00e7\u00e3o, ela tamb\u00e9m cria uma nova tabela chamada Customer e uma chamada Product, cada uma em um DB. A primeira usa o seguinte esquema, em que CustID \u00e9 a chave prim\u00e1ria:</p> <pre><code>Customer(CustID, Name)\n</code></pre> <p>E a segunda usa o seguinte, onde ProdID \u00e9 a chave prim\u00e1ria:</p> <pre><code>Product (ProdID, Name, Price)\n</code></pre> <p>A fun\u00e7\u00e3o tamb\u00e9m usa a PyMySQL para adicionar registros a essa tabela. A fun\u00e7\u00e3o adiciona registros usando os IDs de clientes/produtos e nomes/e ou pre\u00e7os especificados nas mensagens que voc\u00ea adicionar\u00e1 \u00e0 sua fila do Amazon SQS.</p> <p>Observe que o c\u00f3digo cria a conex\u00e3o com seu banco de dados fora da fun\u00e7\u00e3o do manipulador. A cria\u00e7\u00e3o da conex\u00e3o no c\u00f3digo de inicializa\u00e7\u00e3o permite que a conex\u00e3o seja reutilizada por invoca\u00e7\u00f5es subsequentes de sua fun\u00e7\u00e3o e melhora o desempenho. </p> <p>Adicione o novo trecho abaixo no seu main.tf: main.tf<pre><code># C\u00f3digo j\u00e1 existente omitido\n# ...\n\nresource \"local_file\" \"python_script\" {\nfilename = \"./source_lambda/lambda_function.py\"\ncontent  = &lt;&lt;-EOF\nimport sys\nimport logging\nimport pymysql\nimport json\n\n# rds settings db clients\nrds_host_clients  = \"${aws_db_instance.clients.endpoint}\"[:-5]\nuser_name_clients = \"admin\"\npassword_clients  = \"senhaDoBancoDeDados\"\ndb_name_clients   = \"ExampleDB\"\n\n# rds settings db products\nrds_host_products  = \"${aws_db_instance.products.endpoint}\"[:-5]\nuser_name_products = \"admin\"\npassword_products  = \"senhaDoBancoDeDados\"\ndb_name_products   = \"ExampleDB\"\n\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\n# create the database connection outside of the handler to allow connections to be\n# re-used by subsequent function invocations.\ntry:\n    conn = pymysql.connect(host=rds_host_clients, user=user_name_clients, passwd=password_clients, db=db_name_clients, connect_timeout=5)\nexcept pymysql.MySQLError as e:\n    logger.error(\"ERROR: Unexpected error: Could not connect to MySQL instance - clients\")\n    logger.error(e)\n    sys.exit()\n\nlogger.info(\"SUCCESS: Connection to RDS MySQL instance (clients) succeeded\")\n\ntry:\n    conn2 = pymysql.connect(host=rds_host_products, user=user_name_products, passwd=password_products, db=db_name_products, connect_timeout=5)\nexcept pymysql.MySQLError as e:\n    logger.error(\"ERROR: Unexpected error: Could not connect to MySQL instance - products\")\n    logger.error(e)\n    sys.exit()\n\nlogger.info(\"SUCCESS: Connection to RDS MySQL instance (products) succeeded\")\n\ndef lambda_handler(event, context):\n    \"\"\"\n    This function creates a new RDS database table and writes records to it\n    \"\"\"\n    message = event['Records'][0]['body']\n    data = json.loads(message)\n    #diferencia se \u00e9 cliente ou produto\n    if 'CustID' in data:\n        CustID = data['CustID']\n        Name = data['Name']\n\n        item_count = 0\n        sql_string = f\"insert into Customer (CustID, Name) values({CustID}, '{Name}')\"\n\n        with conn.cursor() as cur:\n            cur.execute(\"create table if not exists Customer ( CustID  int NOT NULL, Name varchar(255) NOT NULL, PRIMARY KEY (CustID))\")\n            cur.execute(sql_string)\n            conn.commit()\n            cur.execute(\"select * from Customer\")\n            logger.info(\"The following items have been added to the database clients:\")\n            for row in cur:\n                item_count += 1\n                logger.info(row)\n        conn.commit()\n\n        return \"Added %d items to RDS MySQL table\" %(item_count)\n    else:\n        ProdID = data['ProdID']\n        Name = data['Name']\n        Price = data['Price']\n\n        item_count = 0\n        sql_string = f\"insert into Product (ProdID, Name, Price) values({ProdID}, '{Name}', {Price})\"\n\n        with conn2.cursor() as cur:\n        #price is float with two decimal places\n            cur.execute(\"create table if not exists Product ( ProdID  int NOT NULL, Name varchar(255) NOT NULL, Price float(10,2) NOT NULL, PRIMARY KEY (ProdID))\")\n            cur.execute(sql_string)\n            conn2.commit()\n            cur.execute(\"select * from Product\")\n            logger.info(\"The following items have been added to the database products:\")\n            for row in cur:\n                item_count += 1\n                logger.info(row)\n        conn2.commit()\n\n        return \"Added %d items to RDS MySQL table\" %(item_count)\nEOF\n}\n</code></pre></p> <p>Info</p> <p>Repare que o \"rds_host\" \u00e9 explicitamente dependente dos resources que criam os bancos de dados.  Al\u00e9m disso, o slicing no final \u00e9 feito pois a propriedade .endpoint retorna a porta \":3306\", que a biblioteca pymsql j\u00e1 usa por padr\u00e3o. </p> <p>Warning</p> <p>Use os valores de db_name, username e password pelos que voc\u00ea usou na cria\u00e7\u00e3o dos databases. Em produ\u00e7\u00e3o, \u00e9 recomendado n\u00e3o codificar esses dados em fun\u00e7\u00e3o, mas sim usar o AWS Secrets Manager para armazenar com seguran\u00e7a as credenciais de acesso ao banco de dados.</p> <p>Agora, temos tudo para criar o nosso .zip para a fun\u00e7\u00e3o Lambda:</p> main.tf<pre><code># C\u00f3digo j\u00e1 existente omitido\n# ...\n\ndata \"archive_file\" \"lambda_archive\" {\ndepends_on  = [local_file.python_script]\nsource_dir  = \"./source_lambda\"\noutput_path = \"lambda_function.zip\"\ntype        = \"zip\"\n}\n</code></pre> <p>Info</p> <p>Repare que o resource \"lambda_archive\" \u00e9 implicitamente dependente do resource que cria o arquivo .py. </p> <p>Vamos criar nossa fun\u00e7\u00e3o Lambda. Fazemos isso por meio da inser\u00e7\u00e3o do resource abaixo:</p> main.tf<pre><code># C\u00f3digo j\u00e1 existente omitido\n# ...\n\n# Cria a fun\u00e7\u00e3o Lambda\nresource \"aws_lambda_function\" \"test_lambda\" {\nfilename      = \"lambda_function.zip\"\nfunction_name = \"LambdaFunctionWithRDS-terraform\"\nrole          = aws_iam_role.role.arn\nhandler       = \"lambda_function.lambda_handler\"\nruntime       = \"python3.9\"\n\nvpc_config {\nsubnet_ids         = aws_default_subnet.default[*].id\nsecurity_group_ids = [aws_default_security_group.default.id]\n}\n\ndepends_on = [ data.archive_file.lambda_archive ]\n}\n</code></pre> <p>Info</p> <p>Repare que o resource \"test_lambda\" \u00e9 explicitamente dependente do resource que cria o arquivo .zip. </p> <p>Agora iremos configurar a VPC padr\u00e3o que \u00e9 usada pelos bancos de dados e pelo Lambda. Tamb\u00e9m as mesmas sub-redes para ambos. Al\u00e9m disso, \u00e9 preciso definir regra de entrada para a porta que os bancos de dados usam (:3306) e regra de sa\u00edda (deixaremos todas).</p> main.tf<pre><code># C\u00f3digo j\u00e1 existente omitido\n# ...\n\n\nresource \"aws_default_subnet\" \"default\" {\ncount             = 6\navailability_zone = element([\"us-east-1a\", \"us-east-1b\", \"us-east-1c\", \"us-east-1d\", \"us-east-1e\", \"us-east-1f\"], count.index)\n\n}\n\nresource \"aws_default_security_group\" \"default\" {\nvpc_id = aws_default_vpc.default.id\n\ningress {\nfrom_port   = 3306\nto_port     = 3306\nprotocol    = \"tcp\"\ncidr_blocks = [\"0.0.0.0/0\"]\n}\n\negress {\nfrom_port   = 0\nto_port     = 0\nprotocol    = \"-1\"\ncidr_blocks = [\"0.0.0.0/0\"]\n}\n\n}\n\nresource \"aws_default_vpc\" \"default\" {\n}\n</code></pre> <p>Agora voc\u00ea deve criar a fila do Amazon SQS que usar\u00e1 para invocar sua fun\u00e7\u00e3o do Lambda:</p> main.tf<pre><code># C\u00f3digo j\u00e1 existente omitido\n# ...\n\n# Cria uma fila do Amazon SQS\nresource \"aws_sqs_queue\" \"my_queue\" {\nname = \"LambdaRDSQueue\"\n}\n</code></pre> <p>Agora, iremos criar um mapeamento da origem do evento para invocar sua fun\u00e7\u00e3o do Lambda. </p> <p>Um mapeamento da origem do evento \u00e9 um recurso no Lambda que l\u00ea itens de um fluxo ou de uma fila e invoca uma fun\u00e7\u00e3o do Lambda. Ao configurar um mapeamento da origem do evento, voc\u00ea pode especificar um tamanho de lote para que os registros do seu fluxo ou da sua fila sejam agrupados em uma \u00fanica carga \u00fatil. Neste exemplo, definiremos o tamanho do lote como 1 para que a fun\u00e7\u00e3o do Lambda seja invocada toda vez que voc\u00ea enviar uma mensagem para sua fila.</p> main.tf<pre><code># C\u00f3digo j\u00e1 existente omitido\n# ...\n\n# Cria um mapeamento da origem do evento para invocar sua fun\u00e7\u00e3o do Lambda\nresource \"aws_lambda_event_source_mapping\" \"resource_queue\" {\nevent_source_arn = aws_sqs_queue.my_queue.arn\nfunction_name    = aws_lambda_function.test_lambda.function_name\nbatch_size       = 1\n}\n</code></pre> <p>Precisamos agora criar um sistema para notificar um determinado e-mail quando um registro for inserido no banco de dados.</p> <p>Para isso, faremos uso do SNS, que pode enviar notifica\u00e7\u00f5es de diferentes modos. Utilizaremos o e-mail nesse roteiro. Vamos, ent\u00e3o, configur\u00e1-lo. </p> <p>Para isso, adicione, no main.tf, o seguinte c\u00f3digo:</p> main.tf<pre><code># C\u00f3digo j\u00e1 existente omitido\n# ...\n#Criando um t\u00f3pico de notifica\u00e7\u00f5es no SNS\nresource \"aws_sns_topic\" \"sns_topic\" {\nname = \"LambdaRDSTopic\"\n}\n\n#variavel email_subscription\nvariable \"email_subscription\" {\ntype = string\ndefault = \"email_padrao@gmail.com\"\n}\n\n#Criando uma assinatura no t\u00f3pico\nresource \"aws_sns_topic_subscription\" \"sns_topic_subscription\" {\ntopic_arn = aws_sns_topic.sns_topic.arn\nprotocol  = \"email\"\nendpoint  = var.email_subscription\n}\n</code></pre> <p>Vamos agora criar um alarme no Cloudwatch. Ele ser\u00e1 o respons\u00e1vel por conectar a gera\u00e7\u00e3o de logs da nossa fun\u00e7\u00e3o que insere dados nos bancos de dados ao SNS, que notificar\u00e1 o usu\u00e1rio via e-mail.</p> <p>O alarme que criaremos recebe o ARN do t\u00f3pico que ir\u00e1 gerar a notifica\u00e7\u00e3o, filtra o log espec\u00edfico da fun\u00e7\u00e3o Lambda e muda de estado (de OK para ALARM) conforme surgir log.</p> <p>Para fazer isso, adicionaremos o trecho abaixo no nosso c\u00f3digo:</p> main.tf<pre><code>#Criando uma notifica\u00e7\u00e3o para o t\u00f3pico\nresource \"aws_cloudwatch_metric_alarm\" \"sns_alarm\" {\nalarm_name          = \"LambdaRDSAlarm\"\ncomparison_operator = \"GreaterThanOrEqualToThreshold\"\nevaluation_periods  = \"1\"\nmetric_name         = \"NumberOfMessagesSent\"\nnamespace           = \"AWS/SNS\"\nperiod              = \"60\"\nstatistic           = \"Sum\"\nthreshold           = \"1\"\nalarm_description   = \"This metric monitors sqs queue\"\nalarm_actions       = [aws_sns_topic.sns_topic.arn]\ndimensions = {\nTopicName = aws_sns_topic.sns_topic.name\n}\n}\n\nresource \"aws_cloudwatch_log_metric_filter\" \"lambda_log_filter\" {\nname           = \"LambdaRDSLogFilter\"\npattern        = \"ERROR\"\nlog_group_name = \"/aws/lambda/LambdaFunctionWithRDS-terraform\"\nmetric_transformation {\nname        = \"ErrorCount\"\nnamespace   = \"Custom/CloudWatchLogs\"\nvalue       = \"1\"\ndefault_value = \"0\"\n}\n}\n\nresource \"aws_cloudwatch_metric_alarm\" \"lambda_log_alarm\" {\nalarm_name          = \"lambda-log-alarm\"\nalarm_description   = \"Alarm triggered on CloudWatch Logs\"\ncomparison_operator = \"GreaterThanOrEqualToThreshold\"\nevaluation_periods  = \"1\"\nmetric_name         = \"ErrorCount\"\nnamespace           = \"Custom/CloudWatchLogs\"\nperiod              = \"60\"\nstatistic           = \"SampleCount\"\nthreshold           = \"1\"\nalarm_actions       = [aws_sns_topic.sns_topic.arn]\ntreat_missing_data  = \"missing\"\n}\n\nresource \"aws_cloudwatch_log_metric_filter\" \"lambda_log_filter_subscription\" {\nname           = \"LambdaRDSLogFilterSubscription\"\npattern        = \"SubscriptionError\"\nlog_group_name = \"/aws/lambda/LambdaFunctionWithRDS-terraform\"\nmetric_transformation {\nname        = \"SubscriptionErrorCount\"\nnamespace   = \"Custom/CloudWatchLogs\"\nvalue       = \"1\"\n}\n}\n</code></pre> <p>Agora temos tudo para efetivamente usar o Terraform para criar nossa infraestrutura definida em c\u00f3digo. </p> <p>Para isso, certifique-se que voc\u00ea est\u00e1 com o terminal na pasta terraform.</p> <p>Ent\u00e3o, criamos vari\u00e1veis de ambiente com a chave que criamos no in\u00edcio:</p> <p><pre><code>export AWS_ACCESS_KEY_ID=&lt;ID_CHAVE_DE_ACESSO&gt;\nexport AWS_SECRET_ACCESS_KEY=&lt;CHAVE_SECRETA_DE_ACESSO&gt;\n</code></pre> Esse procedimento evita a exposi\u00e7\u00e3o da senha.</p> <p>Tamb\u00e9m vamos exportar a regi\u00e3o padr\u00e3o, que nesse roteiro \u00e9 \"us-east-1\":</p> <pre><code>export AWS_DEFAULT_REGION=\"us-east-1\"\n</code></pre> <p>Ap\u00f3s isso, vamos iniciar os recursos terraform necess\u00e1rios para provisionar rodando o comando abaixo:</p> <pre><code>terraform init\n</code></pre> <p>Agora veremos o plano de cria\u00e7\u00e3o desses recursos: <pre><code>terraform plan\n</code></pre></p> <p>Por fim, realize deploy dos recursos na nuvem: <pre><code>terraform apply -var=\"&lt;email_a_ser_notificado&gt;\" -auto-approve\n</code></pre></p> <p>Em torno de alguns minutos, se tudo der certo, sua infraestrutura estar\u00e1 criada.</p> <p>O e-mail cadastrado precisa confirmar que deseja receber notifica\u00e7\u00f5es: </p> <p>Voc\u00ea pode verificar que o de banco de dados foi criado acessando este link. O esperado \u00e9 algo como na imagem abaixo: </p> <p>A fun\u00e7\u00e3o do IAM criada pode ser visualizada aqui. Ela possui as permiss\u00f5es definidas.  O esperado \u00e9 algo como na imagem abaixo: </p> <p>Podemos conferir nossa fun\u00e7\u00e3o Lambda aqui.O esperado \u00e9 algo como na imagem abaixo: </p> <p>E nossa fila do SQS pode ser acessada aqui. O esperado \u00e9 algo como na imagem abaixo: </p> <p>O t\u00f3pico SNS aqui O esperado \u00e9 algo como na imagem abaixo: </p> <p>E o alarme aqui.  O esperado \u00e9 algo como na imagem abaixo: </p>"},{"location":"#testando-e-monitorando-a-infraestrutura","title":"Testando e monitorando a infraestrutura","text":"<p>Para testar sua configura\u00e7\u00e3o completa, adicione mensagens \u00e0 sua fila do Amazon SQS usando o console. Siga os passos abaixo:</p> <ul> <li> <p>Abra a p\u00e1gina Filas do console do Amazon SQS e selecione sua fila <code>(LambdaRDSQueue)</code>.</p> </li> <li> <p>Escolha Enviar e receber mensagens e cole o JSON a seguir (exemplo de um cliente) no Corpo da mensagem no painel Enviar mensagem.</p> <pre><code>{\n\"CustID\": 404,\n\"Name\": \"Rodolfo Avelino\"\n}\n</code></pre> <p></p> </li> <li> <p>Escolha Send Message (Enviar mensagem). Essa a\u00e7\u00e3o far\u00e1 com que o Lambda invoque sua fun\u00e7\u00e3o por meio do mapeamento da origem do evento. </p> </li> </ul> <p>Para confirmar que o Lambda invocou sua fun\u00e7\u00e3o conforme o esperado, usaremos o CloudWatch Logs para verificar se a fun\u00e7\u00e3o gravou o nome e o ID do cliente na tabela do seu banco de dados, por meio do grupo de logs criado pela fun\u00e7\u00e3o Lambda. Para isso, siga os passos abaixo:</p> <ul> <li> <p>Abra a p\u00e1gina Grupos de logs do console do CloudWatch e selecione o grupo de logs para sua fun\u00e7\u00e3o <code>(aws/lambda/LambdaFunctionWithRDS-terraform)</code>.</p> </li> <li> <p>No painel Fluxos de logs, escolha o fluxo de logs mais recente.</p> </li> </ul> <p>Sua tabela deve conter um registro de cliente, pois houve uma invoca\u00e7\u00e3o da sua fun\u00e7\u00e3o. No fluxo de logs, voc\u00ea dever\u00e1 ver mensagens semelhantes \u00e0s seguintes:</p> <pre><code>    [INFO]  The following items have been added to the database:\n    [INFO] (404, 'Rodolfo Avelino')\n</code></pre> <p></p> <p>Voc\u00ea tamb\u00e9m deve ter recebido, ou receber\u00e1 em poucos minutos, um e-mail com notifica\u00e7\u00e3o do Alarme, como no exemplo abaixo:</p> <p></p>"},{"location":"#excluindo-a-infraestrutura","title":"Excluindo a infraestrutura","text":"<p>Para excluir os recursos criados para este roteiro, basta executar o comando abaixo:</p> <pre><code>terraform destroy -auto-approve\n</code></pre>"},{"location":"#referencias","title":"Refer\u00eancias","text":"<p>AWS Documentation</p>"}]}